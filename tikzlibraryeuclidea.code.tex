\ProvidesFile{tikzlibraryeuclidea.code.tex}[2025/03/28 v1.8.0 A tikz library for Euclidean geometry constructions]

% \RequirePackage{xfp}

\usetikzlibrary{math,calc,quotes,mc}

% pgfmath-solution to the error:
% Package PGF Math: Could not parse input 'A' as a floating 
% point number, sorry. The unreadable part was near 'A'..
% https://tex.stackexchange.com/questions/455991/pgfmath-function-for-strings-and-numbers
\pgfkeys{
  /pgf/fpu/handlers/invalid number/.code = {%
    \pgfmathfloatparsenumber{3Y0.0e0]}%
  }
}

\makeatletter

% ===============================================
% Caveats
% ===============================================

% function 'intersect/eqs' conflicts with siunitx package

% 在 TikZ 中，函数本身并没有直接的“返回多个值”的机制，因为 TikZ 是一种基于 TeX 的绘图语言，主要用于描述图形，
% 而不是像编程语言那样处理多返回值逻辑。不过，通过一些技巧，你可以在 TikZ 中模拟类似“返回多个值”的效果。
% https://tex.stackexchange.com/questions/510418/tikz-declare-function-with-multiple-outputs

% tikzset 中不要有空行

% 注意: 计算过程是保留坐标单位(pt)的, 所以存在乘除法单位的问题, 首先数值始终携带单位, 
% 在 calc 运算时有的需要转换为标量; 将坐标转换为 pt 值, 数值可能超出限值, 出现 
% Dimension too large 错误, 在计算长度时及时进行缩小 
% https://tex.stackexchange.com/questions/475556/tikz-why-is-dimension-too-large
% 具体方法是修改默认的 1cm, 如: [scale=1.0,x=0.5cm,y=0.5cm]
% 注意此处的变量不要和 tikzpicture 环境重名, 否则被替换掉
% triangle centers: 
% https://mathworld.wolfram.com/BarycentricCoordinates.html

\tikzmath {
  int \cs@TanCnt;
  \cs@TanCnt = 0;
}

\tikzset{
  % specifying start and end with modifiers(see tikz manual 13.5) 
  % commands supporting partway modifiers:
  % radical axis, perpendicular bisector, perpendicular, parallel
  start modifier/.initial = 0,
  % start modifier/.default = 0,
  end modifier/.initial = 1,
  % end modifier/.default = 1,
  % ========== Coordinates Transformations ==========
  % affine={A,B,k}: returns affine combination of two points
  % with affine ratio, i.e. A + k * ( B - A )
  affine/.style args = {#1,#2,#3}{
    insert path = {
      ($(#1)!{#3}!(#2)$)
    }
  },
  % midpoint={A,B}: returns midpoint of AB.
  midpoint/.style args = {#1,#2}{
    insert path = {
      ($(#1)!.5!(#2)$)
    }
  },
  % translate={A,B,C}: returns translation of C by 
  % the vector AB, i.e. C + ( B - A )
  translate/.style args = {#1,#2,#3}{
    insert path = {
      ($(#3)+(#2)-(#1)$)
    }
  },
  % reflect={A,B,C}: reflects point C across line AB. 
  reflect/.style args = {#1,#2,#3}{
    insert path = {
      let
        \p{ft} = ($(#1)!(#3)!(#2)$),% perpendicular foot
      in ($(#3)!2!(\p{ft})$)
    }
  },
  % project={A,B,C}: projects point C onto line AB. 
  project/.style args = {#1,#2,#3}{
    insert path = {
      ($(#1)!(#3)!(#2)$)
    }
  },
  % circle inverse={O,A,P}: returns inverse point P with respect to 
  % a reference circle(O,A). 
  circle inverse/.style args = {#1,#2,#3}{
    insert path = {
      let
        \p{OA} = ($(#2)-(#1)$),
        \p{OP} = ($(#3)-(#1)$),
        \n{r} = {veclen(\p{OA})},
        \n{d} = {veclen(\p{OP})},
        \n1 = {scalar((\n{r}/\n{d}))},
      in ($(#1)!\n1*\n1!(#3)$)
    }
  },
  revolve/scale/.initial = 1,% angle scale
  revolve/@angle/.initial = 90,
  revolve/@argn/.initial = 0,% arguments count
  % set revolve/@angle with certain degrees or angle of a vector
  revolve/@set angle 1/.code args = {#1}{
    \pgfmathanglebetweenpoints
      {\pgfpoint{0cm}{0cm}}
      {\pgfpointanchor{#1}{center}}
    \pgfkeysalso{/tikz/revolve/@angle = \pgfmathresult}
    % \typeout{=========================}
    % \typeout{/tikz/revolve/@angle:\pgfkeysvalueof{/tikz/revolve/@angle}}
    % \typeout{=========================}
  },
  % set revolve/@angle with angle between two position vectors
  revolve/@set angle 2/.code args = {#1,#2}{
    \pgfmathanglebetweenpoints
      {\pgfpointanchor{#1}{center}}
      {\pgfpointanchor{#2}{center}}
    \pgfkeysalso{/tikz/revolve/@angle = \pgfmathresult}
    % \typeout{=========================}
    % \typeout{/tikz/revolve/@angle:\pgfkeysvalueof{/tikz/revolve/@angle}}
    % \typeout{=========================}
  },
  % set revolve/@angle with angle {A,B,C}, angle between two sides
  % (A is apex, B is the start point, C is the end point) 
  revolve/@set angle 3/.code args = {#1,#2,#3}{
    \pgfmathanglebetweenlines
      {\pgfpointanchor{#1}{center}}
      {\pgfpointanchor{#2}{center}}
      {\pgfpointanchor{#1}{center}}
      {\pgfpointanchor{#3}{center}}
    \pgfkeysalso{/tikz/revolve/@angle = \pgfmathresult}
    % \typeout{=========================}
    % \typeout{/tikz/revolve/@angle:\pgfkeysvalueof{/tikz/revolve/@angle}}
    % \typeout{=========================}
  },
  % set revolve/@angle with angle between two vectors(ccw, AB and CD) 
  revolve/@set angle 4/.code args = {#1,#2,#3,#4}{
    \pgfmathanglebetweenlines
      {\pgfpointanchor{#1}{center}}
      {\pgfpointanchor{#2}{center}}
      {\pgfpointanchor{#3}{center}}
      {\pgfpointanchor{#4}{center}}
    \pgfkeysalso{/tikz/revolve/@angle = \pgfmathresult}
    % \typeout{=========================}
    % \typeout{/tikz/revolve/@angle:\pgfkeysvalueof{/tikz/revolve/@angle}}
    % \typeout{=========================}
  },
  revolve/angle/.code = {%
    \pgfmathfloatparsenumber{#1}
    \pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
    \ifnum \F < 3%number
      \pgfmathparse{#1}
    \else
      % Compute the Number of Arguments
      \pgfutil@for\arg:=#1\do{
        \pgfmathparse{int(add(\pgfkeysvalueof{/tikz/revolve/@argn},1))}
        \pgfkeysalso{/tikz/revolve/@argn = \pgfmathresult}
      }
      \ifnum \pgfkeysvalueof{/tikz/revolve/@argn} = 1
        \tikzset{revolve/@set angle 1 = {#1}}
      \else\ifnum \pgfkeysvalueof{/tikz/revolve/@argn} = 2
        \tikzset{revolve/@set angle 2 = {#1}}
      \else\ifnum \pgfkeysvalueof{/tikz/revolve/@argn} = 3
        \tikzset{revolve/@set angle 3 = {#1}}
      \else\ifnum \pgfkeysvalueof{/tikz/revolve/@argn} = 4
        \tikzset{revolve/@set angle 4 = {#1}}
      \else
        \pgferror{"Incorrect number of arguments!"}
      \fi\fi\fi
      \fi
    \fi 
    \pgfkeysalso{/tikz/revolve/@angle = \pgfmathresult}
  },
  % revolve={A,B}: rotates point B by the angle around point A.
  revolve/.style args = {#1,#2}{
    insert path = {
      let 
        \n1 = {\pgfkeysvalueof{/tikz/revolve/@angle}},
        \n2 = {\pgfkeysvalueof{/tikz/revolve/scale}}
      in ($(#1)!1!\n1*\n2:(#2)$)
    }
  },
  % angle bisector={A,B,C}: alias for [revolve/angle={A,B,C},revolve/scale=.5,revolve={A,B}]
  angle bisector/.style args = {#1,#2,#3}{
    revolve/angle={#1,#2,#3},revolve/scale=.5,revolve={#1,#2}
  },
  % erect={A,B}: alias for [revolve/angle=90,revolve={A,B}]
  erect/.style args = {#1,#2}{
    revolve/angle=90,revolve={#1,#2}
  },
  % equilateral={A,B}: alias for [revolve/angle=60,revolve={A,B}]
  equilateral/.style args = {#1,#2}{
    revolve/angle=60,revolve={#1,#2}
  },
  % cut a line segment of a certain length on a straight line
  intercept/@length/.initial = 1cm,
  intercept/scale/.initial = 1,% length scale
  intercept/length/.code = {% set length by distance of segment
    \pgfutil@in@{,}{#1}
    \ifpgfutil@in@%compute segment length
      \euclidea@ComputeLength#1\euclidea@stop
      \pgfkeysalso{/tikz/intercept/@length = \pgfmathresult}
    \else
      \pgfkeysalso{/tikz/intercept/@length = #1}
    \fi
    % \typeout{=========================}
    % \typeout{/tikz/intercept/@length:\pgfkeysvalueof{/tikz/intercept/@length}}
    % \typeout{=========================} 
  },
  % intercept={A,B}: intercepts a line segment(starting 
  % from point A) of a certain length on line AB.
  intercept/.style args = {#1,#2}{
    insert path = {
      let 
        \n1 = {\pgfkeysvalueof{/tikz/intercept/@length}},
        \n2 = {\pgfkeysvalueof{/tikz/intercept/scale}},
        \p{AB} = ($(#2)-(#1)$),
        \n{d} = {veclen(\p{AB})},
        \n3 = {scalar(\n1*\n2/\n{d})}
      in ($(#1)!\n3!(#2)$)
    }
  },
  % intersect={A,B,C,D}: returns the intersection coordinate 
  % of line AB and line CD. 
  % https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
  % system of linear equations in two variables
  % intersect/eqs={a1,b1,c1,a2,b2,c2}: intersection of two lines defined by equations
  % i.e. solving a1x+b1y+c1=0 and a2x+b2y+c2=0 
  intersect/eqs/.code args = {#1,#2,#3,#4,#5,#6} {
    \tikzmath{
      \intersect@a{1,1} = #1; \intersect@a{1,2} = #2; \intersect@b{1,1} = -(#3);
      \intersect@a{2,1} = #4; \intersect@a{2,2} = #5; \intersect@b{2,1} = -(#6);
    }
    \tikzset{solve={\intersect@a,\intersect@b,2,1,\intersect@ans},}
    \typeout{=========================}
    \typeout{Line-Line Intersection:}
    \tikzset{
      stdout={\intersect@a,2,2},
      stdout={\intersect@b,2,1},
      stdout={\intersect@ans,2,1},
    }
    \typeout{=========================}
    % \coordinate (ll) at (\c{1,1},\c{2,1});
  },
  % intersect/pts={A,B,C,D}: intersection of two lines defined by points
  intersect/pts/.code args = {#1,#2,#3,#4}{
    \newdimen\xA
    \newdimen\yA
    \newdimen\xB
    \newdimen\yB
    \newdimen\xC
    \newdimen\yC
    \newdimen\xD
    \newdimen\yD
    \pgfextractx{\xA}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\yA}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\xB}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\yB}{\pgfpointanchor{#2}{center}}
    \pgfextractx{\xC}{\pgfpointanchor{#3}{center}}
    \pgfextracty{\yC}{\pgfpointanchor{#3}{center}}
    \pgfextractx{\xD}{\pgfpointanchor{#4}{center}}
    \pgfextracty{\yD}{\pgfpointanchor{#4}{center}}
    \pgfmathsetmacro{\xa}{\xA / 1cm}
    \pgfmathsetmacro{\ya}{\yA / 1cm}
    \pgfmathsetmacro{\xb}{\xB / 1cm}
    \pgfmathsetmacro{\yb}{\yB / 1cm}
    \pgfmathsetmacro{\xc}{\xC / 1cm}
    \pgfmathsetmacro{\yc}{\yC / 1cm}
    \pgfmathsetmacro{\xd}{\xD / 1cm}
    \pgfmathsetmacro{\yd}{\yD / 1cm}
    \tikzset{
      intersect/eqs={
        \yb-\ya, -(\xb-\xa), -\xa*(\yb-\ya)+\ya*(\xb-\xa),
        \yd-\yc, -(\xd-\xc), -\xc*(\yd-\yc)+\yc*(\xd-\xc)
      }    
    }
  },
  intersect/.style args = {#1,#2,#3,#4}{
    intersect/pts={#1,#2,#3,#4},%invoke code defined above
    insert path = {
      (\intersect@ans{1,1},\intersect@ans{2,1})
    }
  },
  % ========== Triangle Centers ==========
  % calculated from barycentric coordinates
  % incenter = {A,B,C}
  incenter/.style args = {#1,#2,#3}{
    insert path = {
      let
        \p1 = (#1), \p2 = (#2), \p3 = (#3),
        \p{AB} = ($(#2)-(#1)$),
        \p{BC} = ($(#3)-(#2)$),
        \p{CA} = ($(#1)-(#3)$),
        \n{a} = {veclen(\x{BC}, \y{BC})},
        \n{b} = {veclen(\x{CA}, \y{CA})},
        \n{c} = {veclen(\x{AB}, \y{AB})},
        \n{s} = {\n{a}+\n{b}+\n{c}},
        \n1 = {\n{a}/\n{s}}, 
        \n2 = {\n{b}/\n{s}},
        \n3 = {\n{c}/\n{s}},
      in ({\n1*\x1+\n2*\x2+\n3*\x3,\n1*\y1+\n2*\y2+\n3*\y3})
    }
  },
  % excenter = {A,B,C}, returns excenter opposite to the vertex A
  excenter/.style args = {#1,#2,#3}{ 
    insert path = {
      let
        \p1 = (#1), \p2 = (#2), \p3 = (#3),
        \p{AB} = ($(#2)-(#1)$),
        \p{BC} = ($(#3)-(#2)$),
        \p{CA} = ($(#1)-(#3)$),
        \n{a} = {veclen(\x{BC}, \y{BC})},
        \n{b} = {veclen(\x{CA}, \y{CA})},
        \n{c} = {veclen(\x{AB}, \y{AB})},
        \n{s} = {-\n{a}+\n{b}+\n{c}},
        \n1 = {\n{a}/\n{s}}, 
        \n2 = {\n{b}/\n{s}},
        \n3 = {\n{c}/\n{s}},
      in ({-\n1*\x1+\n2*\x2+\n3*\x3,-\n1*\y1+\n2*\y2+\n3*\y3})
    }
  },
  % circumcenter = {A,B,C}
  circumcenter/.style args = {#1,#2,#3}{
    insert path = {
      let
        \p1 = (#1), \p2 = (#2), \p3 = (#3),
        \p{AB} = ($(#2)-(#1)$),
        \p{BC} = ($(#3)-(#2)$),
        \p{CA} = ($(#1)-(#3)$),
        \n{a} = {veclen(\x{BC}, \y{BC})},
        \n{b} = {veclen(\x{CA}, \y{CA})},
        \n{c} = {veclen(\x{AB}, \y{AB})},
        \n{m} = {max(max(\n{a},\n{b}),\n{c})},
        \n{a} = {\n{a}/\n{m}},
        \n{a} = {\n{a}*\n{a}},
        \n{b} = {\n{b}/\n{m}},
        \n{b} = {\n{b}*\n{b}},
        \n{c} = {\n{c}/\n{m}},
        \n{c} = {\n{c}*\n{c}},
        \n1 = {\n{a}*(\n{b}+\n{c}-\n{a})},
        \n2 = {\n{b}*(\n{c}+\n{a}-\n{b})},
        \n3 = {\n{c}*(\n{a}+\n{b}-\n{c})},
        \n{s} = {\n1+\n2+\n3},
        \n1 = {\n1/\n{s}},
        \n2 = {\n2/\n{s}},
        \n3 = {\n3/\n{s}},
      in ({\n1*\x1+\n2*\x2+\n3*\x3,\n1*\y1+\n2*\y2+\n3*\y3})
    }
  },
  % orthocenter = {A,B,C}
  orthocenter/.style args = {#1,#2,#3}{
    insert path = {
      let
        \p1 = (#1), \p2 = (#2), \p3 = (#3),
        \p{AB} = ($(#2)-(#1)$),
        \p{BC} = ($(#3)-(#2)$),
        \p{CA} = ($(#1)-(#3)$),
        \n{a} = {veclen(\x{BC}, \y{BC})},
        \n{b} = {veclen(\x{CA}, \y{CA})},
        \n{c} = {veclen(\x{AB}, \y{AB})},
        \n{m} = {max(max(\n{a},\n{b}),\n{c})},
        \n{a} = {\n{a}/\n{m}},
        \n{a} = {\n{a}*\n{a}},
        \n{b} = {\n{b}/\n{m}},
        \n{b} = {\n{b}*\n{b}},
        \n{c} = {\n{c}/\n{m}},
        \n{c} = {\n{c}*\n{c}},
        \n{a2} = {\n{b}+\n{c}-\n{a}},
        \n{b2} = {\n{c}+\n{a}-\n{b}},
        \n{c2} = {\n{a}+\n{b}-\n{c}},
        \n1 = {\n{c2}*\n{b2}},
        \n2 = {\n{a2}*\n{c2}},
        \n3 = {\n{b2}*\n{a2}},
        \n{s} = {\n1+\n2+\n3},
        \n1 = {\n1/\n{s}},
        \n2 = {\n2/\n{s}},
        \n3 = {\n3/\n{s}},
      in ({\n1*\x1+\n2*\x2+\n3*\x3,\n1*\y1+\n2*\y2+\n3*\y3})
    }
  },
  % centroid = {A,B,C}
  centroid/.style args = {#1,#2,#3}{
    insert path = {
      let
        \p1 = (#1), \p2 = (#2), \p3 = (#3),
      in ({(\x1+\x2+\x3)/3},{(\y1+\y2+\y3)/3})
    }
  },
  % nine-pint center = {A,B,C}
  nine-point center/.style args = {#1,#2,#3}{
    insert path = {
      let
        \p1 = (#1), \p2 = (#2), \p3 = (#3),
        \p{AB} = ($(#2)-(#1)$),
        \p{BC} = ($(#3)-(#2)$),
        \p{CA} = ($(#1)-(#3)$),
        \n{a} = {veclen(\x{BC}, \y{BC})},
        \n{b} = {veclen(\x{CA}, \y{CA})},
        \n{c} = {veclen(\x{AB}, \y{AB})},
        \n{m} = {max(max(\n{a},\n{b}),\n{c})},
        \n{a} = {\n{a}/\n{m}},
        \n{a} = {\n{a}*\n{a}},
        \n{b} = {\n{b}/\n{m}},
        \n{b} = {\n{b}*\n{b}},
        \n{c} = {\n{c}/\n{m}},
        \n{c} = {\n{c}*\n{c}},
        \n1 = {\n{a}*(\n{b}+\n{c})-(\n{b}-\n{c})*(\n{b}-\n{c})},
        \n2 = {\n{b}*(\n{c}+\n{a})-(\n{c}-\n{a})*(\n{c}-\n{a})},
        \n3 = {\n{c}*(\n{a}+\n{b})-(\n{a}-\n{b})*(\n{a}-\n{b})},
        \n{s} = {\n1+\n2+\n3},
        \n1 = {\n1/\n{s}},
        \n2 = {\n2/\n{s}},
        \n3 = {\n3/\n{s}},
      in ({\n1*\x1+\n2*\x2+\n3*\x3,\n1*\y1+\n2*\y2+\n3*\y3})
    }
  },
  % ========== Circle Operations ==========
  % circle = {O,A}, creates circle with the center (O) through A
  circle/.style args = {#1,#2}{
    insert path = {
      let
        \p{OA} = ($(#2)-(#1)$),
      in (#1) circle ({veclen(\p{OA})})
    }
  },
  % tagent point = {O,A,P} NOTE: deprecated
  % O,A: center of circle and an abitary point on the circle 
  % P: a point outside the circle
  tangent point/.style args = {#1,#2,#3}{
    insert path = {
      let 
        \p{OA} = ($(#2)-(#1)$), % 半径
        \p{OP} = ($(#3)-(#1)$), 
        \n1 = {veclen(\p{OA})},
        \n2 = {veclen(\p{OP})},
        \n3 = {scalar(\n1/\n2)}
      in ($(#1)!\n3!{acos(\n1/\n2)}:(#3)$)
    }
  },
  % external homothetic center
  % O1,A1: center of circle 1 and an abitary point on the circle 
  % O2,A2: center of circle 2 and an abitary point on the circle
  external center/.style args = {#1,#2,#3,#4}{
    insert path = {
      let 
        \p{O1A1} = ($(#2)-(#1)$),% 半径O1A1
        \p{O2A2} = ($(#4)-(#3)$),% 半径O2A2
        \n{r1} = {veclen(\p{O1A1})},
        \n{r2} = {veclen(\p{O2A2})},
        \n1 = {scalar(\n{r1}/(\n{r1}-\n{r2}))}
      in ($(#1)!\n1!(#3)$)
    }
  },
  % internal homothetic center
  % O1,A1: center of circle 1 and an abitary point on the circle 
  % O2,A2: center of circle 2 and an abitary point on the circle
  internal center/.style args = {#1,#2,#3,#4}{
    insert path = {
      let 
        \p{O1A1} = ($(#2)-(#1)$),% 半径O1A1
        \p{O2A2} = ($(#4)-(#3)$),% 半径O2A2
        \n{r1} = {veclen(\p{O1A1})},
        \n{r2} = {veclen(\p{O2A2})},
        \n1 = {scalar(\n{r1}/(\n{r1}+\n{r2}))}
      in ($(#1)!\n1!(#3)$)
    }
  },
  % creates the radical axis of two non-concentric circles
  % O1,A1: center of circle 1 and an abitary point on the circle 
  % O2,A2: center of circle 2 and an abitary point on the circle
  radical axis/.style args = {#1,#2,#3,#4}{
    insert path = {
      let 
        \n{s} = {\pgfkeysvalueof{/tikz/start modifier}},
        \n{e} = {\pgfkeysvalueof{/tikz/end modifier}},
        \p{O1A1} = ($(#2)-(#1)$),% 半径O1A1
        \p{O2A2} = ($(#4)-(#3)$),% 半径O2A2
        \p{O1O2} = ($(#3)-(#1)$),
        \n{r1} = {veclen(\p{O1A1})},
        \n{r2} = {veclen(\p{O2A2})},
        \n{d} = {veclen(\p{O1O2})},
        \n1 = {scalar(\n{r1}/\n{d})},
        \n2 = {scalar(\n{r2}/\n{d})},
        \n3 = {.5*(1+\n1*\n1-\n2*\n2)},
        \p{ft} = ($(#1)!\n3!(#3)$),% perpendicular foot
        \p{s0} = ($(\p{ft})+(-\y{O1O2},\x{O1O2})$),
        \p{e0} = ($(\p{ft})+(\y{O1O2},-\x{O1O2})$),
        \p{s} = ($(\p{s0})!\n{s}!(\p{e0})$),% start   
        \p{e} = ($(\p{s0})!\n{e}!(\p{e0})$)% end    
      in (\p{s}) -- (\p{e})
    }
  },
  % circle-line instersections (named: cl1, cl2) of circle (O, A) 
  % and line (P, Q)
  % circle-line/eqs={xo,yo,r,a,b,c}: intersections of circle and line 
  % defined by equations, 
  % (x-xo)^2+(y-yo)^2=r^2 and ax+by+c=0
  circle-line/eqs/.code args = {#1,#2,#3,#4,#5,#6} {
    \tikzmath {
      % x sinθ - y cosθ + C = 0
      % θ: angle between the line and x-axis, [0,pi)
      \cl@temp = sqrt((#4)^2+(#5)^2);
      if (#4) >=0 then {
        \cl@a = (#4)/\cl@temp; % sin theta
        \cl@b = (#5)/\cl@temp; % - cos theta
        \cl@c = (#6)/\cl@temp;
      } else {
        \cl@a = -(#4)/\cl@temp;
        \cl@b = -(#5)/\cl@temp;
        \cl@c = -(#6)/\cl@temp;
      };
      \cl@dist = abs(\cl@a*#1+\cl@b*#2+\cl@c);
      if \cl@dist <= #3 then {
        \cl@offset = sqrt((#3)^2-(\cl@dist)^2);
      } else {
        \cl@offset = 0.0;% no intersection
      };
    } 
    % foot of the perpendicular from the center of a circle to a line
    \tikzset{
      intersect/eqs={
        -(#5),#4,(#5)*(#1)-(#4)*(#2),% 如果 #n 本身是表达式, 则应加上括号
        #4,#5,#6
      }
    };

    \typeout{=========================}
    \typeout{Circle: center (#1, #2) radius #3}
    \typeout{Line coefficients(normalized): \cl@a, \cl@b, \cl@c}
    \typeout{Circle-line distance: \cl@dist}
    \typeout{Offset: \cl@offset}
    \typeout{=========================}

    % circle-line intersections
    \coordinate (cl1) at (\intersect@ans{1,1}-\cl@b*\cl@offset,\intersect@ans{2,1}+\cl@a*\cl@offset);
    \coordinate (cl2) at (\intersect@ans{1,1}+\cl@b*\cl@offset,\intersect@ans{2,1}-\cl@a*\cl@offset);
  },
  circle-line/.code args = {#1,#2,#3,#4}{% 
    \newdimen\xO
    \newdimen\yO
    \newdimen\xA
    \newdimen\yA
    \newdimen\xP
    \newdimen\yP
    \newdimen\xQ
    \newdimen\yQ
    \pgfextractx{\xO}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\yO}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\xA}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\yA}{\pgfpointanchor{#2}{center}}
    \pgfextractx{\xP}{\pgfpointanchor{#3}{center}}
    \pgfextracty{\yP}{\pgfpointanchor{#3}{center}}
    \pgfextractx{\xQ}{\pgfpointanchor{#4}{center}}
    \pgfextracty{\yQ}{\pgfpointanchor{#4}{center}}
    \pgfmathsetmacro{\xo}{\xO / 1cm}
    \pgfmathsetmacro{\yo}{\yO / 1cm}
    \pgfmathsetmacro{\xa}{\xA / 1cm}
    \pgfmathsetmacro{\ya}{\yA / 1cm}
    \pgfmathsetmacro{\xp}{\xP / 1cm}
    \pgfmathsetmacro{\yp}{\yP / 1cm}
    \pgfmathsetmacro{\xq}{\xQ / 1cm}
    \pgfmathsetmacro{\yq}{\yQ / 1cm}

    \tikzmath {
      \cl@ra = veclen(\xa-\xo,\ya-\yo);
    } 
    \tikzset {
      circle-line/eqs={
        \xo,\yo,\cl@ra,
        \yq-\yp,-(\xq-\xp),-\xp*(\yq-\yp)+\yp*(\xq-\xp)
      }
    }
  },
  % circle-circle instersections (named: cc1, cc2) of circle 
  % O1(A, B) and circle O2(C, D)
  circle-circle/.code args = {#1,#2,#3,#4}{% 
    \newdimen\xA% center 1
    \newdimen\yA
    \newdimen\xB
    \newdimen\yB
    \newdimen\xC% center 2
    \newdimen\yC
    \newdimen\xD
    \newdimen\yD
    \pgfextractx{\xA}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\yA}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\xB}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\yB}{\pgfpointanchor{#2}{center}}
    \pgfextractx{\xC}{\pgfpointanchor{#3}{center}}
    \pgfextracty{\yC}{\pgfpointanchor{#3}{center}}
    \pgfextractx{\xD}{\pgfpointanchor{#4}{center}}
    \pgfextracty{\yD}{\pgfpointanchor{#4}{center}}
    \pgfmathsetmacro{\xa}{\xA / 1cm}
    \pgfmathsetmacro{\ya}{\yA / 1cm}
    \pgfmathsetmacro{\ra}{veclen(\xB-\xA, \yB-\yA) / 1cm}
    \pgfmathsetmacro{\xb}{\xC / 1cm}
    \pgfmathsetmacro{\yb}{\yC / 1cm}
    \pgfmathsetmacro{\rb}{veclen(\xD-\xC, \yD-\yC) / 1cm}
    
    \tikzset {
      circle-line/eqs={
        \xa,\ya,\ra,
        2*(\xb-\xa),2*(\yb-\ya),(\xa)^2+(\ya)^2-(\ra)^2-(\xb)^2-(\yb)^2+(\rb)^2
      }
    }

    % circle-circle intersections
    \coordinate (cc1) at (cl1);
    \coordinate (cc2) at (cl2);
  },
  % tangent lines to circle: circle-tagent = {O,A,P}, create 
  % tangent points (named: tp1, tp2, tp1 is on the left side of OP )
  % O,A: center of circle and an abitary point on the circle 
  % P: a point outside the circle
  circle-tangent/.code args = {#1,#2,#3} {
    \coordinate (euclidea@mid) at ($(#1)!.5!(#3)$);
    \tikzset{circle-circle={#1,#2,euclidea@mid,#1},}
    \coordinate (tp1) at (cc1);
    \coordinate (tp2) at (cc2);
  },
  % ========== Path Definitions ==========
  % perpendicular bisector of the line segment (#1 -- #2)
  perpendicular bisector/.style args = {#1,#2}{
    insert path = { 
      let
        \n{s} = {\pgfkeysvalueof{/tikz/start modifier}},
        \n{e} = {\pgfkeysvalueof{/tikz/end modifier}},
        \p{AB} = ($(#2)-(#1)$),
        \p{m} = ($(#1)!0.5!(#2)$),% midpoint
        \p{s0} = ($(\p{m})+(-\y{AB},\x{AB})$),% rotate ccw, default start
        \p{e0} = ($(\p{m})+(\y{AB},-\x{AB})$),% rotate cw, default end
        \p{s} = ($(\p{s0})!\n{s}!(\p{e0})$),% start
        \p{e} = ($(\p{s0})!\n{e}!(\p{e0})$)% end
      in (\p{s}) -- (\p{e})
    }
  },
  % perpendicular line of the line (#1 -- #2) through #3
  % specifying start and end with modifiers(see tikz manual 13.5) 
  perpendicular/.style args = {#1,#2,#3}{
    insert path = {
      let
        \n{s} = {\pgfkeysvalueof{/tikz/start modifier}},
        \n{e} = {\pgfkeysvalueof{/tikz/end modifier}},
        \p{AB} = ($(#2)-(#1)$),
        \p{ft} = ($(#1)!(#3)!(#2)$),% perpedicular foot  
        \p{s0} = ($(\p{ft})+(-\y{AB},\x{AB})$),
        \p{e0} = ($(\p{ft})+(\y{AB},-\x{AB})$),
        \p{s} = ($(\p{s0})!\n{s}!(\p{e0})$),% start   
        \p{e} = ($(\p{s0})!\n{e}!(\p{e0})$)% end    
      in (\p{s}) -- (\p{e})
    }
  },
  % parallel line of the line (#1 -- #2) through #3
  % specifying start and end with modifiers(see tikz manual 13.5) 
  parallel/.style args = {#1,#2,#3}{
    insert path = {
      let
        \n{s} = {\pgfkeysvalueof{/tikz/start modifier}},
        \n{e} = {\pgfkeysvalueof{/tikz/end modifier}},
        \p{s0} = (#3),
        \p{e0} = ($(#3)+(#2)-(#1)$),    
        \p{s} = ($(\p{s0})!\n{s}!(\p{e0})$),% start   
        \p{e} = ($(\p{s0})!\n{e}!(\p{e0})$)% end  
      in (\p{s}) -- (\p{e})
    }
  },
  % alias for parallel={A,B,A}
  extend/.style args = {#1,#2} {
    parallel={#1,#2,#1}
  },
  % rotate around the origin by `angle` and then 
  % shift by (`xshift`,`yshift`)
  % rotate-translate = {angle:(xshift,yshift)}
  % {x',y'} = {{cosθ,-sinθ},{sinθ,cosθ}}*{x,y}+{xshift,yshift}
  rotate-translate/.style args = {#1:(#2,#3)} {
    cm={cos(#1), sin(#1), -sin(#1), cos(#1), (#2,#3)}
  },
  % {x',y'} = {{cosθ,-sinθ},{sinθ,cosθ}}*{x+xshift, y+yshift}
  translate-rotate/.style args = {#1:(#2,#3)} {
    cm={cos(#1), sin(#1), -sin(#1), cos(#1), 
    ({(#2)*cos(#1)-(#3)*sin(#1)},{(#2)*sin(#1)+(#3)*cos(#1)})}
  },
  % ========== Conics Definitions ==========
  % ellipse with foci and a point
  ellipse/a/.initial = 0,
  ellipse/b/.initial = 0,
  ellipse/c/.initial = 0,
  ellipse/e/.initial = 0,
  ellipse/angle/.initial = 0,
  ellipse/xcenter/.initial = 0,
  ellipse/ycenter/.initial = 0,
  ellipse/define/.code args = {#1,#2,#3}{
    % 提取各点的坐标分量 x-coordinate and y-coordinate
    % 注意: 根据 LaTeX 的规则, 宏不能含有数字, 
    % 提取坐标的 x 和 y 分量的宏不要含有数字
    \newdimen\xFL
    \newdimen\yFL
    \newdimen\xFR
    \newdimen\yFR
    \newdimen\xP
    \newdimen\yP
    \pgfextractx{\xFL}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\yFL}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\xFR}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\yFR}{\pgfpointanchor{#2}{center}}
    \pgfextractx{\xP}{\pgfpointanchor{#3}{center}}
    \pgfextracty{\yP}{\pgfpointanchor{#3}{center}}

    % semimajor axis: a = |PF1 - PF2| / 2
    \pgfmathsetmacro{\PFLeft}{veclen(\xP-\xFL, \yP-\yFL)} % 计算 PF1
    \pgfmathsetmacro{\PFRight}{veclen(\xP-\xFR, \yP-\yFR)} % 计算 PF2
    \pgfmathsetmacro{\a}{abs(\PFLeft + \PFRight) / 2cm} % 计算 a 并转换单位

    % the distance from the center to a focus: c = |F1F2| / 2
    \pgfmathsetmacro{\c}{veclen(\xFL-\xFR, \yFL-\yFR) / 2cm} 

    % semiminor axis: b = sqrt(a^2 - c^2)
    \pgfmathsetmacro{\b}{sqrt(\a^2 - \c^2)}

    % ellipse eccentricity
    \pgfmathsetmacro{\e}{\c/\a}

    % ellipse center
    \pgfmathsetmacro{\xcenter}{(\xFL + \xFR) / 2cm} 
    \pgfmathsetmacro{\ycenter}{(\yFL + \yFR) / 2cm} 

    % angle of rotation
    \pgfmathsetmacro{\angle}{atan2(\yFR-\yFL, \xFR-\xFL)} 

    \pgfkeysalso{/tikz/ellipse/a = \a}
    \pgfkeysalso{/tikz/ellipse/b = \b}
    \pgfkeysalso{/tikz/ellipse/c = \c}
    \pgfkeysalso{/tikz/ellipse/e = \e}
    \pgfkeysalso{/tikz/ellipse/xcenter = \xcenter}
    \pgfkeysalso{/tikz/ellipse/ycenter = \ycenter}
    \pgfkeysalso{/tikz/ellipse/angle = \angle}
    \typeout{=========================}
    \typeout{
      ellipse:{
        a:\pgfkeysvalueof{/tikz/ellipse/a}, 
        b:\pgfkeysvalueof{/tikz/ellipse/b}, 
        c:\pgfkeysvalueof{/tikz/ellipse/c}, 
        angle:\pgfkeysvalueof{/tikz/ellipse/angle}, 
        center:(\pgfkeysvalueof{/tikz/ellipse/xcenter},
          \pgfkeysvalueof{/tikz/ellipse/ycenter})
      }
    }
    \typeout{=========================}
  },
  ellipse/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/ellipse/a}},
        \n{b} = {\pgfkeysvalueof{/tikz/ellipse/b}},
        \n{angle} = {\pgfkeysvalueof{/tikz/ellipse/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/ellipse/xcenter}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/ellipse/ycenter}},
      in [rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        (0,0) ellipse [x radius=\n{a},y radius=\n{b}]
    }
  },
  % ellipse directrices: k = 1.25
  %   (-a^2/c, -k*b) -- (-a^2/c, k*b)
  %   ( a^2/c, -k*b) -- ( a^2/c, k*b)
  ellipse/directrix/scale/.initial = 1.25,
  % ellipse/directrix/scale/.code args= {#1}{
  %   \pgfkeysalso{/tikz/ellipse/directrix/scale = #1}
  % },
  ellipse/directrix/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/ellipse/a}},
        \n{b} = {\pgfkeysvalueof{/tikz/ellipse/b}},
        \n{c} = {\pgfkeysvalueof{/tikz/ellipse/c}},
        \n{d} = {\n{a}^2/\n{c}},
        \n{scale} = {\pgfkeysvalueof{/tikz/ellipse/directrix/scale}},
        \n{angle} = {\pgfkeysvalueof{/tikz/ellipse/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/ellipse/xcenter}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/ellipse/ycenter}},
      in [rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        (-\n{d}, -\n{b}*\n{scale}) -- (-\n{d}, \n{b}*\n{scale})
        ( \n{d}, -\n{b}*\n{scale}) -- ( \n{d}, \n{b}*\n{scale})
    }
  },
  % ellipse axes: k = 1.5
  %   (-k*a, 0) -- (k*a, 0)
  %   (0, -k*b) -- (0, k*b)
  ellipse/axis/scale/.initial = 1.5,
  % ellipse/axis/scale/.code args= {#1}{
  %   \pgfkeysalso{/tikz/ellipse/axis/scale = #1}
  % },
  ellipse/axis/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/ellipse/a}},
        \n{b} = {\pgfkeysvalueof{/tikz/ellipse/b}},
        \n{scale} = {\pgfkeysvalueof{/tikz/ellipse/axis/scale}},
        \n{angle} = {\pgfkeysvalueof{/tikz/ellipse/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/ellipse/xcenter}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/ellipse/ycenter}},
      in [rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        (-\n{scale}*\n{a}, 0) -- (\n{scale}*\n{a}, 0)
        (0, -\n{scale}*\n{b}) -- (0, \n{scale}*\n{b})
    }
  },
  % hyperbola with foci and a point
  % hyperbola parametric equation: x = a*cosh(t), y = b*sinh(t)
  hyperbola/domain/.initial=-1.5:1.5,
  % hyperbola/doamin/.code args = {#1}{
  %   \pgfkeysalso{/tikz/hyperbola/domain = #1}
  % },
  hyperbola/a/.initial = 0,
  hyperbola/b/.initial = 0,
  hyperbola/c/.initial = 0,
  hyperbola/e/.initial = 0,
  hyperbola/angle/.initial = 0,
  hyperbola/xcenter/.initial = 0,
  hyperbola/ycenter/.initial = 0,
  hyperbola/define/.code args = {#1,#2,#3}{
    % 提取各点的坐标分量 x-coordinate and y-coordinate
    % 注意: 根据 LaTeX 的规则, 宏不能含有数字, 
    % 提取坐标的 x 和 y 分量的宏不要含有数字
    \newdimen\xFL
    \newdimen\yFL
    \newdimen\xFR
    \newdimen\yFR
    \newdimen\xP
    \newdimen\yP
    \pgfextractx{\xFL}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\yFL}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\xFR}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\yFR}{\pgfpointanchor{#2}{center}}
    \pgfextractx{\xP}{\pgfpointanchor{#3}{center}}
    \pgfextracty{\yP}{\pgfpointanchor{#3}{center}}

    % semimajor axis: a = |PF1 - PF2| / 2
    \pgfmathsetmacro{\PFLeft}{veclen(\xP-\xFL, \yP-\yFL)} % 计算 PF1
    \pgfmathsetmacro{\PFRight}{veclen(\xP-\xFR, \yP-\yFR)} % 计算 PF2
    \pgfmathsetmacro{\a}{abs(\PFLeft - \PFRight)/2cm} % 计算 a 并转换单位

    % the distance from the center to a focus: c = |F1F2| / 2
    \pgfmathsetmacro{\c}{veclen(\xFL-\xFR, \yFL-\yFR) / 2cm}

    % semiminor axis: b = sqrt(c^2 - a^2)
    \pgfmathsetmacro{\b}{sqrt(\c^2 - \a^2)} 

    % hyperbola eccentricity
    \pgfmathsetmacro{\e}{\c/\a} 

    % hyperbola center
    \pgfmathsetmacro{\xcenter}{(\xFL + \xFR) / 2cm} 
    \pgfmathsetmacro{\ycenter}{(\yFL + \yFR) / 2cm} 

    % angle of rotation
    \pgfmathsetmacro{\angle}{atan2(\yFR-\yFL, \xFR-\xFL)}

    \pgfkeysalso{/tikz/hyperbola/a = \a}
    \pgfkeysalso{/tikz/hyperbola/b = \b}
    \pgfkeysalso{/tikz/hyperbola/c = \c}
    \pgfkeysalso{/tikz/hyperbola/e = \e}
    \pgfkeysalso{/tikz/hyperbola/xcenter = \xcenter}
    \pgfkeysalso{/tikz/hyperbola/ycenter = \ycenter}
    \pgfkeysalso{/tikz/hyperbola/angle = \angle}
    \typeout{=========================}
    \typeout{
      hyperbola:{
        a:\pgfkeysvalueof{/tikz/hyperbola/a}, 
        b:\pgfkeysvalueof{/tikz/hyperbola/b}, 
        c:\pgfkeysvalueof{/tikz/hyperbola/c}, 
        angle:\pgfkeysvalueof{/tikz/hyperbola/angle}, 
        center:(\pgfkeysvalueof{/tikz/hyperbola/xcenter},
          \pgfkeysvalueof{/tikz/hyperbola/ycenter})
      }
    }
    \typeout{=========================}
  },
  hyperbola/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/hyperbola/a}},
        \n{b} = {\pgfkeysvalueof{/tikz/hyperbola/b}},
        \n{angle} = {\pgfkeysvalueof{/tikz/hyperbola/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/hyperbola/xcenter}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/hyperbola/ycenter}},
      in [smooth,domain=\pgfkeysvalueof{/tikz/hyperbola/domain},
      variable=\euclidea@var,rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        plot({-\n{a}*cosh(\euclidea@var)},{\n{b}*sinh(\euclidea@var)})  % right branch
        plot({ \n{a}*cosh(\euclidea@var)},{\n{b}*sinh(\euclidea@var)})  % left branch
    }
  },
  % asymptote parametric equation: x = a*sinh(t), y = b*sinh(t)
  asymptote/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/hyperbola/a}},
        \n{b} = {\pgfkeysvalueof{/tikz/hyperbola/b}},
        \n{angle} = {\pgfkeysvalueof{/tikz/hyperbola/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/hyperbola/xcenter}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/hyperbola/ycenter}},
      in [smooth,domain=\pgfkeysvalueof{/tikz/hyperbola/domain},
      variable=\euclidea@var,rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        plot({-\n{a}*sinh(\euclidea@var)},{\n{b}*sinh(\euclidea@var)})  
        plot({ \n{a}*sinh(\euclidea@var)},{\n{b}*sinh(\euclidea@var)})  
    }
  },
  % hyperbola directrices: k = 1.5
  %   (-a^2/c, -k*b) -- (-a^2/c, k*b)
  %   ( a^2/c, -k*b) -- ( a^2/c, k*b)
  hyperbola/directrix/scale/.initial = 1.5,
  % hyperbola/directrix/scale/.code args= {#1}{
  %   \pgfkeysalso{/tikz/hyperbola/directrix/scale = #1}
  % },
  hyperbola/directrix/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/hyperbola/a}},
        \n{b} = {\pgfkeysvalueof{/tikz/hyperbola/b}},
        \n{c} = {\pgfkeysvalueof{/tikz/hyperbola/c}},
        \n{d} = {\n{a}^2/\n{c}},
        \n{scale} = {\pgfkeysvalueof{/tikz/hyperbola/directrix/scale}},
        \n{angle} = {\pgfkeysvalueof{/tikz/hyperbola/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/hyperbola/xcenter}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/hyperbola/ycenter}},
      in [rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        (-\n{d}, -\n{scale}*\n{b}) -- (-\n{d}, \n{scale}*\n{b})
        ( \n{d}, -\n{scale}*\n{b}) -- ( \n{d}, \n{scale}*\n{b})
    }
  },
  % hyperbola axes: k = 1.5
  %   (-k*c, 0) -- (k*c, 0)
  %   (0, -k*b) -- (0, k*b)
  hyperbola/axis/scale/.initial = 1.5,
  % hyperbola/axis/scale/.code args= {#1}{
  %   \pgfkeysalso{/tikz/hyperbola/axis/scale = #1}
  % },
  hyperbola/axis/.style = {
    insert path = {
      let
        \n{b} = {\pgfkeysvalueof{/tikz/hyperbola/b}},
        \n{c} = {\pgfkeysvalueof{/tikz/hyperbola/c}},
        \n{scale} = {\pgfkeysvalueof{/tikz/hyperbola/axis/scale}},
        \n{angle} = {\pgfkeysvalueof{/tikz/hyperbola/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/hyperbola/xcenter}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/hyperbola/ycenter}},
      in [rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        (-\n{scale}*\n{c}, 0) -- (\n{scale}*\n{c}, 0)
        (0, -\n{scale}*\n{b}) -- (0, \n{scale}*\n{b})
    }
  },
  % parabola with the focus and vertex
  % parabola parametric equation: 
  % y^2 = 4a*x, x = a*t^2, y= 2a*t
  % The quantity 4a is known as the latus rectum.
  parabola/domain/.initial=-3:3,
  % parabola/doamin/.code args = {#1}{
  %   \pgfkeysalso{/tikz/parabola/domain = #1}
  % },
  parabola/a/.initial = 0,
  parabola/e/.initial = 1,
  parabola/angle/.initial = 0,
  parabola/@xvertex/.initial = 0,
  parabola/@yvertex/.initial = 0,
  parabola/define/.code args = {#1,#2}{
    % 提取各点的坐标分量 x-coordinate and y-coordinate
    % 注意: 根据 LaTeX 的规则, 宏不能含有数字, 
    % 提取坐标的 x 和 y 分量的宏不要含有数字
    \newdimen\xF
    \newdimen\yF
    \newdimen\xV
    \newdimen\yV
    \pgfextractx{\xF}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\yF}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\xV}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\yV}{\pgfpointanchor{#2}{center}}

    % latus rectum 4a
    % 注意: semi-latus rectum 通常表示为 p (=2a), 
    % macro 不要定义为 \p, \p 有表示向量的含义
    \pgfmathsetmacro{\a}{veclen(\xV-\xF, \yV-\yF) / 1cm} % 计算 PF
    
    % parabola vertex
    \pgfmathsetmacro{\xvertex}{(\xV) / 1cm} 
    \pgfmathsetmacro{\yvertex}{(\yV) / 1cm} 

    % angle of rotation
    \pgfmathsetmacro{\angle}{atan2(\yF-\yV, \xF-\xV)}

    \pgfkeysalso{/tikz/parabola/a = \a}
    \pgfkeysalso{/tikz/parabola/@xvertex = \xvertex}
    \pgfkeysalso{/tikz/parabola/@yvertex = \yvertex}
    \pgfkeysalso{/tikz/parabola/angle = \angle}
    \typeout{=========================}
    \typeout{
      parabola:{
        a:\pgfkeysvalueof{/tikz/parabola/a}, 
        angle:\pgfkeysvalueof{/tikz/parabola/angle}, 
        center:(\pgfkeysvalueof{/tikz/parabola/@xvertex},
          \pgfkeysvalueof{/tikz/parabola/@yvertex})
      }
    }
    \typeout{=========================}
  },  
  parabola/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/parabola/a}},
        \n{angle} = {\pgfkeysvalueof{/tikz/parabola/angle}},
        \n{xvertex} = {\pgfkeysvalueof{/tikz/parabola/@xvertex}},
        \n{yvertex} = {\pgfkeysvalueof{/tikz/parabola/@yvertex}},
      in [smooth,domain=\pgfkeysvalueof{/tikz/parabola/domain},
      variable=\euclidea@var,
      rotate-translate={\n{angle}:(\n{xvertex},\n{yvertex})}]
        plot({\n{a}*(\euclidea@var)^2},{2*\n{a}*(\euclidea@var)}) 
    }
  },
  % parabola directrix: k = 2
  %   (-a, -k*a) -- (-a, 2k*a)
  parabola/directrix/scale/.initial = 2,
  % parabola/directrix/scale/.code args= {#1}{
  %   \pgfkeysalso{/tikz/parabola/directrix/scale = #1}
  % },
  parabola/directrix/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/parabola/a}},
        \n{scale} = {\pgfkeysvalueof{/tikz/parabola/directrix/scale}},
        \n{angle} = {\pgfkeysvalueof{/tikz/parabola/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/parabola/@xvertex}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/parabola/@yvertex}},
      in [rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        (-\n{a}, -2*\n{scale}*\n{a}) -- (-\n{a}, 2*\n{scale}*\n{a})
    }
  },
  % parabola directrix: k = 2
  %   (-2a, 0) -- (k^2*a, 0)
  parabola/axis/scale/.initial = 2,
  % parabola/axis/scale/.code args= {#1}{
  %   \pgfkeysalso{/tikz/parabola/axis/scale = #1}
  % },
  parabola/axis/.style = {
    insert path = {
      let
        \n{a} = {\pgfkeysvalueof{/tikz/parabola/a}},
        \n{scale} = {\pgfkeysvalueof{/tikz/parabola/axis/scale}},
        \n{angle} = {\pgfkeysvalueof{/tikz/parabola/angle}},
        \n{xcenter} = {\pgfkeysvalueof{/tikz/parabola/@xvertex}},
        \n{ycenter} = {\pgfkeysvalueof{/tikz/parabola/@yvertex}},
      in [rotate-translate={\n{angle}:(\n{xcenter},\n{ycenter})}]
        (-2*\n{a}, 0) -- (\n{scale}^2*\n{a},0)
    }
  },
  % ========== Conics Transformaitons ==========
  % create the matrix of a quadratic form
  % conic/matrix={\q,a,b,c,d,e,f}
  conic/matrix/.code args = {#1,#2,#3,#4,#5,#6,#7} {
    \tikzmath {
      #1{1,1} = (#2);     #1{1,2} = (#3) / 2; #1{1,3} = (#5) / 2; 
      #1{2,1} = (#3) / 2; #1{2,2} = (#4);     #1{2,3} = (#6) / 2; 
      #1{3,1} = (#5) / 2; #1{3,2} = (#6) / 2; #1{3,3} = (#7); 
    }
  },
  % eliminate the cross term in a quadratic form by rotation
  % conic/rotate={\q,\qr,\angle}
  % \qr: the quadratic matrix after rotation 
  % \angle: rotation angle
  conic/rotate/.code args = {#1,#2,#3} {
    \tikzmath {
      if abs(#1{1,2}) > \EPSILON then {
        real \cs@c, \cs@s, \cs@t, \cs@tau;
        \cs@tau = \fpeval{(#1{1,1}-#1{2,2})/(2*#1{1,2})};
        if \cs@tau >= 0 then {
          \cs@t = \fpeval{- \cs@tau + sqrt(1+(\cs@tau)^2)};
        } else {
          \cs@t = \fpeval{- \cs@tau - sqrt(1+(\cs@tau)^2)};
        };
        \cs@c = \fpeval{1 / sqrt(1+(\cs@t)^2)};
        \cs@s = \fpeval{\cs@t * \cs@c};
        #3 = atan(\cs@t);
        % print{\cs@c, \cs@s, angle:#3\\};
        % perform rotation
        #2{1,1} = #1{1,1}*(\cs@c)^2 + #1{1,2}*2*\cs@s*\cs@c + #1{2,2}*(\cs@s)^2;
        #2{1,2} = 0.0;
        #2{1,3} = #1{1,3}*\cs@c + #1{2,3}*\cs@s;
        #2{2,2} = #1{1,1}*(\cs@s)^2 - #1{1,2}*2*\cs@s*\cs@c + #1{2,2}*(\cs@c)^2;
        #2{2,3} = -#1{1,3}*\cs@s + #1{2,3}*\cs@c;
        #2{3,3} = #1{3,3};
        % symetric
        #2{2,1} = #2{1,2};
        #2{3,1} = #2{1,3};
        #2{3,2} = #2{2,3};
      } else {
        % unchanged
        #3 = 0;
        int \cs@i, \cs@j;
        for \cs@i in {1,2,3} {
          for \cs@j in {1,2,3} {
            #2{\cs@i,\cs@j} = #1{\cs@i,\cs@j};
          };
        };
      };
    }
  },
  % translate the origin of axes to the center(of ellipse or hyperbola)
  % or vertex (of parabola)
  % conic/translate={\q,\qt,\xshift,\yshift}
  % \qt : the quadratic matrix after translation 
  % \xshift,\yshift: the center or vertex
  conic/translate/.code args = {#1,#2,#3,#4} {
    \tikzset{
      cofactors={#1,3,\cs@cofactors},
    }
    \tikzmath{
      if abs(\cs@cofactors{3,3}) > \EPSILON then {
        % ellipse or hyperbola
        #3 = \fpeval{\cs@cofactors{3,1} / \cs@cofactors{3,3}};
        #4 = \fpeval{\cs@cofactors{3,2} / \cs@cofactors{3,3}};
      } else {
        % parabola
        if abs(#1{1,1}) > \EPSILON then {
          #3 = \fpeval{- #1{1,3} / #1{1,1}};
          #4 = \fpeval{((#1{1,3})^2 - #1{1,1}*#1{3,3})/(2*#1{1,1}*#1{2,3})};
        } else {
          #3 = \fpeval{((#1{2,3})^2 - #1{2,2}*#1{3,3})/(2*#1{2,2}*#1{1,3})};
          #4 = \fpeval{- #1{2,3} / #1{2,2}};
        };%if
      };%if
      % perform translation
      #2{1,1} = #1{1,1}; #2{1,2} = #1{1,2};
      #2{2,1} = #1{2,1}; #2{2,2} = #1{2,2};
      #2{1,3} = \fpeval{#1{1,1}*#3 + #1{1,2}*#4 + #1{1,3}};
      #2{2,3} = \fpeval{#1{1,2}*#3 + #1{2,2}*#4 + #1{2,3}};
      #2{3,3} = \fpeval{(#3)^2*#1{1,1} + 2*#3*#4*#1{1,2} + (#4)^2*#1{2,2} + 
                         2*#3*#1{1,3} + 2*#4*#1{2,3} + #1{3,3}};
      % symetric
      #2{3,1} = #2{1,3};
      #2{3,2} = #2{2,3};
    }%tikzmath
  },
  % reduce conic matrix from general to standard form
  % conic/reduce={\q,\qs,\angle,\xshift,\yshift,\q}
  % \q: the quadratic matrix in a general form
  % \qs: the quadratic matrix in a standard form
  % \angle: rotation angle
  % \xshift,\yshift: new origin 
  conic/reduce/.code args = {#1,#2,#3,#4,#5} {
    \tikzset {
      conic/rotate={#1,\cs@qr,#3},
      % xshift yshift names should not conflict with those of conic/define
      conic/translate={\cs@qr,\cs@qt,\conic@xshift,\conic@yshift},
    }
    \tikzmath {
      if abs(\cs@qt{1,1}) > \EPSILON && abs(\cs@qt{2,2}) > \EPSILON then {
        % ellipse or hyperbola
        \cs@qt{1,1} = \fpeval{-\cs@qt{1,1} / \cs@qt{3,3}};
        \cs@qt{2,2} = \fpeval{-\cs@qt{2,2} / \cs@qt{3,3}};
        \cs@qt{3,3} = -1.0;
      } else {
        % parabola
        if abs(\cs@qt{1,1}) < \EPSILON then {
          \cs@qt{1,3} = \fpeval{\cs@qt{1,3} / \cs@qt{2,2}};
          \cs@qt{3,1} = \cs@qt{1,3};
          \cs@qt{2,2} = 1.0;
        } else {
          \cs@qt{2,3} = \fpeval{\cs@qt{2,3} / \cs@qt{1,1}};
          \cs@qt{3,2} = \cs@qt{2,3};
          \cs@qt{1,1} = 1.0;      
        };%if
      };%if
      int \cs@i, \cs@j;
      for \cs@i in {1,2,3} {
        for \cs@j in {1,2,3} {
          #2{\cs@i,\cs@j} = \cs@qt{\cs@i,\cs@j};
        };
      };
      % restore xshift and yshift in the original coordinate system
      #4 = \conic@xshift * cos(#3) - \conic@yshift * sin(#3);
      #5 = \conic@xshift * sin(#3) + \conic@yshift * cos(#3);
    }%tikzmath
  },
  conic/define/.code args = {#1,#2,#3,#4,#5,#6}{
    \tikzset {
      conic/matrix={\cs@q,#1,#2,#3,#4,#5,#6},
      conic/reduce={\cs@q,\cs@r,\cs@angle,\cs@xshift,\cs@yshift},
    }
    \tikzmath {
      real \cs@a, \cs@b;
      \cs@a = 0.0; \cs@b = 0.0;
      if \cs@r{1,1} > \EPSILON  && \cs@r{2,2} > \EPSILON then {%ellipse
        \cs@type = 1;
        \cs@a = sqrt(1/\cs@r{1,1});
        \cs@b = sqrt(1/\cs@r{2,2});
      }; 
      if abs(\cs@r{1,1}) <= \EPSILON then {%parabola: y^2 = 4ax
        \cs@type = 2;
        \cs@a = -\cs@r{1,3}/2;
      };
      if abs(\cs@r{2,2}) <= \EPSILON then {%parabola: x^2 = 4ay
        \cs@type = 2;
        \cs@angle = \cs@angle + 90;
        \cs@a = -\cs@r{2,3}/2;
      };
      if \cs@r{1,1} > \EPSILON  && \cs@r{2,2} < -\EPSILON then {%hyperbola
        \cs@type = 3;
        \cs@a = sqrt( 1/\cs@r{1,1});
        \cs@b = sqrt(-1/\cs@r{2,2});
      }; 
      if \cs@r{1,1} < -\EPSILON  && \cs@r{2,2} > \EPSILON then {%hyperbola
        \cs@type = 3;
        \cs@angle = \cs@angle + 90;
        \cs@b = sqrt(-1/\cs@r{1,1});
        \cs@a = sqrt( 1/\cs@r{2,2});
      }; 
    }
    \typeout{=========================}
    \typeout{the matrix of the quadratic equation in general form:}
    \tikzset{stdout={\cs@q,3,3},}
    \typeout{the matrix of the quadratic equation in standard form:}
    \tikzset{stdout={\cs@r,3,3},}
    \typeout{a: \cs@a, b: \cs@b}
    \typeout{type: \cs@type}
    \typeout{transform: \cs@angle:(\cs@xshift,\cs@yshift)}
    \typeout{=========================}
  },
  % conic through 5 points
  conic/five points/.code args = {#1,#2,#3,#4,#5}{
    \newdimen\cs@xa
    \newdimen\cs@ya
    \newdimen\cs@xb
    \newdimen\cs@yb
    \newdimen\cs@xc
    \newdimen\cs@yc
    \newdimen\cs@xd
    \newdimen\cs@yd
    \newdimen\cs@xe
    \newdimen\cs@ye
    \pgfextractx{\cs@xa}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\cs@ya}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\cs@xb}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\cs@yb}{\pgfpointanchor{#2}{center}}
    \pgfextractx{\cs@xc}{\pgfpointanchor{#3}{center}}
    \pgfextracty{\cs@yc}{\pgfpointanchor{#3}{center}}
    \pgfextractx{\cs@xd}{\pgfpointanchor{#4}{center}}
    \pgfextracty{\cs@yd}{\pgfpointanchor{#4}{center}}
    \pgfextractx{\cs@xe}{\pgfpointanchor{#5}{center}}
    \pgfextracty{\cs@ye}{\pgfpointanchor{#5}{center}}
    \pgfmathsetmacro{\cs@xa}{(\cs@xa) / 1cm} 
    \pgfmathsetmacro{\cs@ya}{(\cs@ya) / 1cm} 
    \pgfmathsetmacro{\cs@xb}{(\cs@xb) / 1cm} 
    \pgfmathsetmacro{\cs@yb}{(\cs@yb) / 1cm} 
    \pgfmathsetmacro{\cs@xc}{(\cs@xc) / 1cm} 
    \pgfmathsetmacro{\cs@yc}{(\cs@yc) / 1cm} 
    \pgfmathsetmacro{\cs@xd}{(\cs@xd) / 1cm} 
    \pgfmathsetmacro{\cs@yd}{(\cs@yd) / 1cm} 
    \pgfmathsetmacro{\cs@xe}{(\cs@xe) / 1cm} 
    \pgfmathsetmacro{\cs@ye}{(\cs@ye) / 1cm} 

    \tikzmath{
      \cs@x{1} = \cs@xa; \cs@y{1} = \cs@ya;
      \cs@x{2} = \cs@xb; \cs@y{2} = \cs@yb;
      \cs@x{3} = \cs@xc; \cs@y{3} = \cs@yc;
      \cs@x{4} = \cs@xd; \cs@y{4} = \cs@yd;
      \cs@x{5} = \cs@xe; \cs@y{5} = \cs@ye;
      % 'Dimension too large' error will likely occurrs, because the value 
      % is too large when calculating the cofactor. The coordinates will be
      % normalized to resolve this error.
      \cs@max = 0.0;
      int \i;
      for \i in {1,...,5}{
        if \cs@max < abs(\cs@x{\i}) then {
          \cs@max = abs(\cs@x{\i});
        };
        if \cs@max < abs(\cs@y{\i}) then {
          \cs@max = abs(\cs@y{\i});
        };
      };
      % \cs@max = \fpeval{sqrt(\cs@max)};
      for \i in {1,...,5}{
        \cs@x{\i} = \fpeval{\cs@x{\i}/\cs@max};%normalized
        \cs@y{\i} = \fpeval{\cs@y{\i}/\cs@max};%normalized
        \cs@a{\i,1} = \fpeval{(\cs@x{\i})^2};
        \cs@a{\i,2} = \fpeval{\cs@x{\i}*\cs@y{\i}};
        \cs@a{\i,3} = \fpeval{(\cs@y{\i})^2}; 
        \cs@a{\i,4} = \cs@x{\i}; 
        \cs@a{\i,5} = \cs@y{\i};
        \cs@a{\i,6} = 1.0;
      };
      % placeholder
      \cs@a{6,1} = 0.0; \cs@a{6,2} = 0.0; \cs@a{6,3} = 0.0; 
      \cs@a{6,4} = 0.0; \cs@a{6,5} = 0.0; \cs@a{6,6} = 0.0; 
    }
    \tikzset{
      cofactors={\cs@a,6,\cs@b},
      conic/define={\cs@b{6,1},\cs@b{6,2},\cs@b{6,3},\cs@max*\cs@b{6,4},\cs@max*\cs@b{6,5},\cs@max*\cs@max*\cs@b{6,6}}
    }
  },
  % conic tagent to 5 lines
  % maximum paramters: 9 
  % aq tangent step by step
  % normalize all points and lines in order to resolve 'Dimension too large' and
  % numerical overflow or underflow in calculating cofactors
  conic/five tangents/once/.code args = {#1,#2}{
    \newdimen\cs@xa
    \newdimen\cs@ya
    \newdimen\cs@xb
    \newdimen\cs@yb
    \pgfextractx{\cs@xa}{\pgfpointanchor{#1}{center}}
    \pgfextracty{\cs@ya}{\pgfpointanchor{#1}{center}}
    \pgfextractx{\cs@xb}{\pgfpointanchor{#2}{center}}
    \pgfextracty{\cs@yb}{\pgfpointanchor{#2}{center}}
    \pgfmathsetmacro{\cs@xa}{(\cs@xa) / 1cm} 
    \pgfmathsetmacro{\cs@ya}{(\cs@ya) / 1cm} 
    \pgfmathsetmacro{\cs@xb}{(\cs@xb) / 1cm} 
    \pgfmathsetmacro{\cs@yb}{(\cs@yb) / 1cm} 
    \tikzmath {
      \cs@TanCnt = \cs@TanCnt + 1;
      \cs@tangents{\cs@TanCnt,1} = \cs@xa;
      \cs@tangents{\cs@TanCnt,2} = \cs@ya;
      \cs@tangents{\cs@TanCnt,3} = \cs@xb;
      \cs@tangents{\cs@TanCnt,4} = \cs@yb;
      if \cs@TanCnt == 5 then {
        int \cs@i, \cs@j;
        \cs@max = 0.0;
        for \cs@i in {1,...,5} {
          for \cs@j in {1,...,4} {
            if \cs@max < abs(\cs@tangents{\cs@i,\cs@j}) then {
              \cs@max = abs(\cs@tangents{\cs@i,\cs@j});
            };
          };
        };
        % improve numerical precision
        \cs@max = \fpeval{sqrt(\cs@max)};
        for \cs@i in {1,...,5} {
          for \cs@j in {1,...,4} {
            \cs@tangents{\cs@i,\cs@j} = \fpeval{\cs@tangents{\cs@i,\cs@j} / \cs@max};
          };
        };
        for \cs@i in {1,...,5} {
          \cs@u = \fpeval{\cs@tangents{\cs@i,4} - \cs@tangents{\cs@i,2}};
          \cs@v = \fpeval{-(\cs@tangents{\cs@i,3} - \cs@tangents{\cs@i,1})};
          \cs@w = \fpeval{
            -(\cs@tangents{\cs@i,4} - \cs@tangents{\cs@i,2})*\cs@tangents{\cs@i,1} 
            +(\cs@tangents{\cs@i,3} - \cs@tangents{\cs@i,1})*\cs@tangents{\cs@i,2}
          };
          \cs@temp = \fpeval{sqrt((\cs@u)^2+(\cs@v)^2)};
          \cs@u = \fpeval{\cs@u / \cs@temp};
          \cs@v = \fpeval{\cs@v / \cs@temp};
          \cs@w = \fpeval{\cs@w / \cs@temp};
          \cs@a{\cs@i,1} = \fpeval{(\cs@u)^2};
          \cs@a{\cs@i,2} = \fpeval{\cs@u*\cs@v};
          \cs@a{\cs@i,3} = \fpeval{(\cs@v)^2};
          \cs@a{\cs@i,4} = \fpeval{\cs@u*\cs@w};
          \cs@a{\cs@i,5} = \fpeval{\cs@v*\cs@w};
          \cs@a{\cs@i,6} = \fpeval{(\cs@w)^2};
        };
        % placeholder
        \cs@a{6,1} = 0.0; \cs@a{6,2} = 0.0; \cs@a{6,3} = 0.0; 
        \cs@a{6,4} = 0.0; \cs@a{6,5} = 0.0; \cs@a{6,6} = 0.0; 
      };
    }
    \ifnum \cs@TanCnt = 5
    \tikzset{
      % stdout={\cs@tangents,5,4},
      cofactors={\cs@a,6,\cs@c},
      % stdout={\cs@a,6,6},
      % stdout={\cs@c,6,6},
      % maxabs={\cs@c,6,6,\cs@max},
      normalize={\cs@c,6,6,\cs@b},
      % stdout={\cs@b,6,6},
      % find the dual conic
      conic/matrix={\cs@dual,\cs@b{6,1},\cs@b{6,2},\cs@b{6,3},\cs@b{6,4},\cs@b{6,5},\cs@b{6,6}},
      % stdout={\cs@dual,3,3},
      % for non-degraded conic, the matrix is invertible
      inverse={\cs@dual,3,\cs@q},
      % stdout={\cs@q,3,3},
      % conic/define={\cs@q{1,1},2*\cs@q{1,2},\cs@q{2,2},2*\cs@max*\cs@q{1,3},2*\cs@max*\cs@q{2,3},\cs@max*\cs@max*\cs@q{3,3}},
      conic/define={\cs@q{1,1}/\cs@max,2*\cs@q{1,2}/\cs@max,\cs@q{2,2}/\cs@max,2*\cs@q{1,3},2*\cs@q{2,3},\cs@max*\cs@q{3,3}},
    }
    \tikzmath {
      % reset tangents count
      \cs@TanCnt = 0;
    }
    \fi
  },
  conic/.style = {
    insert path = {
      \ifnum \cs@type = 1 %ellipse
        [rotate-translate={\cs@angle:(\cs@xshift,\cs@yshift)}]
        (0,0) ellipse [x radius=\cs@a,y radius=\cs@b]
      \else\ifnum \cs@type = 2%parabola
        [smooth,domain=\pgfkeysvalueof{/tikz/parabola/domain},
        variable=\euclidea@var,
        rotate-translate={\cs@angle:(\cs@xshift,\cs@yshift)}]
        plot({\cs@a*(\euclidea@var)^2},{2*\cs@a*(\euclidea@var)}) 
      \else\ifnum \cs@type = 3%hyperbola
        [smooth,domain=\pgfkeysvalueof{/tikz/hyperbola/domain},
        variable=\euclidea@var,
        rotate-translate={\cs@angle:(\cs@xshift,\cs@yshift)}]
        plot({-\cs@a*cosh(\euclidea@var)},{\cs@b*sinh(\euclidea@var)})  % right branch
        plot({ \cs@a*cosh(\euclidea@var)},{\cs@b*sinh(\euclidea@var)})  % left branch
      \fi\fi\fi
    }
  },
}

% Utilities for implementation of 'intercept'
\def\euclidea@ComputeLength#1,#2\euclidea@stop{
  \newdimen\euclidea@ax
  \newdimen\euclidea@ay
  \newdimen\euclidea@bx
  \newdimen\euclidea@by
  \pgfextractx{\euclidea@ax}{\pgfpointanchor{#1}{center}}
  \pgfextracty{\euclidea@ay}{\pgfpointanchor{#1}{center}}
  \pgfextractx{\euclidea@bx}{\pgfpointanchor{#2}{center}}
  \pgfextracty{\euclidea@by}{\pgfpointanchor{#2}{center}}
  % 以下 showthe 指令 overleaf.com 编译通过, 而在 macOS+texlive 2021 报错
  % \showthe\euclidea@ax
  % \showthe\euclidea@ay
  % \showthe\euclidea@bx
  % \showthe\euclidea@by
  \pgfmathveclen{\euclidea@ax-\euclidea@bx}{\euclidea@ay-\euclidea@by}
}


% Syntax of parabola: y = a * x * x + b * x + c
%   \parabola [options] (a,b,c); 
\newcommand\parabola{} % just for safety
\def\parabola[#1]#2(#3,#4,#5){
  \path[smooth,domain=-2:2,#1,variable=\euclidea@var]
    plot({\euclidea@var},
      {(#3)*\euclidea@var*\euclidea@var+(#4)*\euclidea@var+(#5)})
}

% Syntax of ellipse:
%   \ellipse [options] (a,b); 
% wherein, a,b are major/minor semi axis.
\newcommand\ellipse{} % just for safety
\def\ellipse[#1]#2(#3,#4){
  \path[#1] (0,0) ellipse ({#3} and {#4})
}

% Syntax of hyperbola:
%   \hyperbola [options] (a,b); 
% wherein, a,b are major/minor semi axis.
\newcommand\hyperbola{} % just for safety
\def\hyperbola[#1]#2(#3,#4){
  \path[smooth,domain=-1.5:1.5,#1,variable=\euclidea@var]
    plot({-(#3)*cosh(\euclidea@var)},
      {(#4)*sinh(\euclidea@var)})% right arm
    plot({ (#3)*cosh(\euclidea@var)},
      {(#4)*sinh(\euclidea@var)})% left arm
}

% Syntax of asymptote:
%   \asymptote [options] (a,b); 
% wherein, a,b are major/minor semi axis.
\newcommand\asymptote{} % just for safety
\def\asymptote[#1]#2(#3,#4){
  \path[domain=-2:2,#1,variable=\euclidea@var,]
    plot({\euclidea@var},{ (#4)/(#3)*(\euclidea@var)})  
    plot({\euclidea@var},{-(#4)/(#3)*(\euclidea@var)}) 
}

% Syntax of axes:
%   \axes (xmin:xmax, ymin:ymax);
\newcommand\axes{}
\def\axes(#1:#2,#3:#4){
  \draw[help lines] (#1,#3) grid[step=1] (#2,#4);
  \draw[-latex] ({(#1)-0.5},0) -- ({(#2)+0.5},0) node[below] {$x$};
  \draw[-latex] (0,{(#3)-0.5}) -- (0,{(#4)+0.5}) node[left] {$y$};
  \draw (0,0) node[below left] {$O$}
}

\makeatother
